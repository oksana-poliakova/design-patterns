//
//  Summary.swift
//  design_patterns
//
//  Created by Oksana Poliakova on 07.02.2023.
//

import Foundation

/*
 The SOLID principles are:

 1) Single Responsibility Principle (SRP): A class should have only one reason to change. This means that a class should only have one responsibility and be focused on doing that one thing well.
 
 2) Open-Closed Principle (OCP): Software entities should be open for extension, but closed for modification. This means that the code should be written in such a way that it can be extended without changing the existing code.
 
 3) Liskov Substitution Principle (LSP): Subtypes should be substitutable for their base types. This means that objects of a derived class should be able to replace objects of the base class without affecting the correctness of the program.
 
 4) Interface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they do not use. This means that the interface should be broken down into smaller, more specific interfaces to reduce the amount of unnecessary code.
 
 5) Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules. Both should depend on abstractions. This means that the code should be written in such a way that it depends on abstractions rather than concrete implementations.
 
 To implement the SOLID principles in Swift, you should aim to write code that follows the following practices:

 - Use protocols and extensions to extend functionality without modifying existing code.
 - Write small, focused classes that have a single responsibility.
 - Use inheritance and polymorphism to allow derived classes to be substituted for their base classes.
 - Use protocols and delegates to break down large interfaces into smaller, more specific interfaces.
 - Use dependency injection to reduce the coupling between different parts of the code.
 
 */
